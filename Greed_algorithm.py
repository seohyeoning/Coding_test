"""
#1. 거스름돈 문제
- 거스름돈 500, 100, 50, 10원짜리 동전 무한히 존재
- 손님에게 거슬러 주어야 할 돈이 N원일 때, 동전의 최소 개수를 구하라 
- 단, N은 항상 10의 배수

해결방법: 가장 큰 화폐 단위부터 거슬러 주기
정당성 분석: 큰 단위가 항상 작은 단위의 배수임
시간복잡도: 화폐의 갯수 (동전의 종류)
"""
n = 1260
count = 0

array = [500, 100, 50, 10]

for coin in array:
    count += n // coin # 몫 값(코인 갯수)을 count에 할당
    n %= coin # coin값을 n으로 나누고 남은 값(나머지 금액)을 n에 할당 

print(count)


"""
#2. 1이 될 때 까지 문제
- 어떠한 수 N이 1이 될 때까지 아래 두 과정 중 하나를 반복적으로 수행하려고 한다. 단 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.
   1) N에서 1을 뺌 
   2) N을 K로 나눔
- N과 K가 주어질 때, N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하라.

해결방법: 주어진 N에 대해서 최대한 많이 나누어야 최소 횟수가 나온다.
정당성 분석: k가 2 이상이기만 하면, 1을 빼는 작업보다 수를 훨씬 많이 줄일 수 있음
시간복잡도: 로그 시간복잡도 (빠른 실행을 위한 테크닉 사용)
"""

n, k = map(int, input().split()) # N, K 공백 기준으로 입력
result = 0

while True: # True면 반복
    # N이 K로 나누어 떨어지는 수가 될 때까지 빼기
    target = (n // k) * k # 테크닉: 가장 가까운 k로 나누어 떨어지는 수 찾기 
    result += (n-target) # 1을 빼는 연산횟수 계산
    n = target

    # N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k :
      break
      
    # K로 나눈 횟수 더하기
    result += 1
    n //= k # k로 나눈 몫을 n에 할당

# 마지막으로 남은 수에 대해 1씩 빼기
result += (n-1) # n이 1이 될 때까지 진행되는 -1 연산 횟수를 result에 업데이트
print(result)
