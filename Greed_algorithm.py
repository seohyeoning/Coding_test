"""
#1. 거스름돈 문제
- 거스름돈 500, 100, 50, 10원짜리 동전 무한히 존재
- 손님에게 거슬러 주어야 할 돈이 N원일 때, 동전의 최소 개수를 구하라 
- 단, N은 항상 10의 배수

해결방법: 가장 큰 화폐 단위부터 거슬러 주기
정당성 분석: 큰 단위가 항상 작은 단위의 배수임
시간복잡도: 화폐의 갯수 (동전의 종류)
"""
n = 1260
count = 0

array = [500, 100, 50, 10]

for coin in array:
    count += n // coin # 몫 값(코인 갯수)을 count에 할당
    n %= coin # coin값을 n으로 나누고 남은 값(나머지 금액)을 n에 할당 

print(count)


"""
#2. 1이 될 때 까지 문제
- 어떠한 수 N이 1이 될 때까지 아래 두 과정 중 하나를 반복적으로 수행하려고 한다. 단 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.
   1) N에서 1을 뺌 
   2) N을 K로 나눔
- N과 K가 주어질 때, N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성하라.

해결방법: 주어진 N에 대해서 최대한 많이 나누어야 최소 횟수가 나온다.
정당성 분석: k가 2 이상이기만 하면, 1을 빼는 작업보다 수를 훨씬 많이 줄일 수 있음
시간복잡도: 로그 시간복잡도 (빠른 실행을 위한 테크닉 사용)
"""

n, k = map(int, input().split()) # N, K 공백 기준으로 입력
result = 0

while True: # True면 반복
    # N이 K로 나누어 떨어지는 수가 될 때까지 빼기
    target = (n // k) * k # 테크닉: 가장 가까운 k로 나누어 떨어지는 수 찾기 
    result += (n-target) # 1을 빼는 연산횟수 계산
    n = target

    # N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k :
      break
      
    # K로 나눈 횟수 더하기
    result += 1
    n //= k # k로 나눈 몫을 n에 할당

# 마지막으로 남은 수에 대해 1씩 빼기
result += (n-1) # n이 1이 될 때까지 진행되는 -1 연산 횟수를 result에 업데이트
print(result)


"""
#3. 곱하기 혹은 더하기
- 각 자리가 숫자로만 이루어진 문자열 S가 주어짐 (ex. "20349")
- 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자사이에 곱셈이나 덧셈 연산자를 넣어라
- 결과적으로 가장 큰 수가 만들어지도록 하는 프로그램을 작성하라
- 단, 모든 연산은 왼쪽부터 순서대로 이루어짐

해결방법: 두 수 중에 하나라도 1 초과이면 곱셈 연산을 해야 함
정당성 분석: 두 수 중에 0이나 1이 있다면 덧셈을 하는 것이 최대값을 얻을 수 있음
"""
data = input()
result = int(data[0]) # 첫 번째 문자를 숫자로 변경하여 대입

for i in range(1, len(data)):
    num = int(data[i])
    if result <= 1 or num <= 1:
      result += num
    else:
      result *= num

print(result)

